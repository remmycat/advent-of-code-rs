use aoc_utils::{ascii_int::parse_uint, trim::trim_end_newline};

#[derive(Debug, PartialEq, Eq)]
pub struct Solution(usize, usize);

const COMMA: u8 = b',';
const DASH: u8 = b'-';
const TEN: usize = 10;

// assuming max length of 12
// following should probably be generated by compiletime functions but rust
// won't let me do it nicely i think :(

const TEN_POWERS: [usize; 12] = [
	TEN.pow(0),
	TEN.pow(1),
	TEN.pow(2),
	TEN.pow(3),
	TEN.pow(4),
	TEN.pow(5),
	TEN.pow(6),
	TEN.pow(7),
	TEN.pow(8),
	TEN.pow(9),
	TEN.pow(10),
	TEN.pow(11),
];

const fn factor_to_repeat_digits_n_times(digit_len: usize, n: usize) -> usize {
	//= (0..n)
	// 	.map(|k| BASE_TEN.pow((k * digit_len) as u32))
	// 	.sum();
	match (digit_len, n) {
		(_, 1) => 1,
		(1, 2) => 11,
		(1, 3) => 111,
		(1, 4) => 1111,
		(1, 5) => 11111,
		(1, 6) => 111111,
		(1, 7) => 1111111,
		(1, 8) => 11111111,
		(1, 9) => 111111111,
		(1, 10) => 1111111111,
		(1, 11) => 11111111111,
		(1, 12) => 111111111111,
		(2, 2) => 101,
		(2, 3) => 10101,
		(2, 4) => 1010101,
		(2, 5) => 101010101,
		(2, 6) => 10101010101,
		(3, 2) => 1001,
		(3, 3) => 1001001,
		(3, 4) => 1001001001,
		(4, 2) => 10001,
		(4, 3) => 100010001,
		(5, 2) => 100001,
		(6, 2) => 1000001,
		_ => unimplemented!(),
	}
}

fn first_n_of_k_digits_divisor(n: usize, k: usize) -> usize {
	// example if n=6, k=2, 123456 was our number, we want 12 so / 10^(6-2)
	let exponent = k - n;
	if exponent > 11 {
		unimplemented!();
	}
	TEN_POWERS[exponent]
}

pub fn solve(input: &[u8]) -> Solution {
	let input = trim_end_newline(input);

	let pair_iter = input.split(|b| *b == COMMA).map(|range_str| {
		let dash_pos = range_str
			.iter()
			.position(|b| *b == DASH)
			.expect("range must have dash separator");
		let (a_str, b_str) = (
			&range_str[0..dash_pos],
			&range_str[(dash_pos + 1)..(range_str.len())],
		);
		(a_str, parse_uint(a_str), b_str, parse_uint(b_str))
	});

	let mut invalid_sum: usize = 0;
	let mut big_invalid_sum: usize = 0;

	for (a_str, a, b_str, b) in pair_iter {
		let (start_len, end_len) = (a_str.len(), b_str.len());

		// Possible split points: any integer between 2 and end length
		// example 3
		for repetitions in 2..=end_len {
			// we only care about numbers that divide by split_len without rest
			let start_group_len = start_len.div_ceil(repetitions);
			let end_group_len = end_len.div_euclid(repetitions);

			// e.g 2..=3
			'len_loop: for group_len in start_group_len..=end_group_len {
				// e.g. 6 this is fix inside this loop! only 6-digit numbers
				let full_len = repetitions * group_len;
				let group_divisor = first_n_of_k_digits_divisor(group_len, full_len);

				// The range of the repeated group. e.g 1-3 with 2 reps
				// to check 11, 22, 33
				let (group_value_start, group_value_end) = (
					if full_len == start_len {
						a / group_divisor
					} else {
						TEN_POWERS[group_len - 1]
					},
					if full_len == end_len {
						b / group_divisor
					} else {
						// Note the -1 outside the brackets! e.g. 99 not 10
						TEN_POWERS[group_len] - 1
					},
				);

				if group_value_end < group_value_start {
					break;
				}
				// e.g 12 * 10101 = 121212 // 10^4 + 10^2 + 10^0 (3 reps)
				// or 123 * 1001 = 123123 // 10^3 + 10^0 (2 reps)
				let repetition_base: usize =
					factor_to_repeat_digits_n_times(group_len, repetitions);

				'group_loop: for group in group_value_start..=group_value_end {
					let full_id = group * repetition_base;
					if full_id > b {
						// outside of valid range, check next possible length
						// with current amount of repetitions
						continue 'len_loop;
					}
					if full_id < a {
						// not reached valid range yet
						continue 'group_loop;
					}

					// we got a valid number inside the given range

					if repetitions == 2 {
						// only count doublings for this sum
						invalid_sum += full_id;
					}

					// Before we count the ID for the bigger sum, we must check
					// that we haven't counted it using less repetitions.
					// This check is pretty inexpensive in comparison to
					// collecting a set.
					for other_reps in 2..repetitions {
						if full_len % other_reps != 0 {
							// current length is not producible using
							// <other_reps> repetitions
							continue;
						}

						let other_group_len = full_len / other_reps;

						let repeated_digits =
							full_id / first_n_of_k_digits_divisor(other_group_len, full_len);

						let other_id = repeated_digits
							* factor_to_repeat_digits_n_times(other_group_len, other_reps);

						if other_id == full_id {
							// found a previous catch, skip to next group
							continue 'group_loop;
						}
					}

					// If we reached this point we haven't counted the id yet
					big_invalid_sum += full_id;
				}
			}
		}
	}

	Solution(invalid_sum, big_invalid_sum)
}

#[cfg(test)]
mod tests {
	use super::*;
	use rstest::rstest;

	#[rstest]
	#[case::example(
		include_bytes!("../inputs/example.txt"),
		Solution(1227775554,4174379265),
	)]
	#[case::personal(
		include_bytes!("../inputs/personal.txt"),
		Solution(22062284697,46666175279),
	)]
	fn solution(#[case] input: &[u8], #[case] expected: Solution) {
		assert_eq!(solve(input), expected);
	}
}
